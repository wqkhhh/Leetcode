## 动态规划

#### 定义
d[i][j] 表示当前是[i,len-1]的剩余石子，然后选择堆数为j，先手的最大数量的石头
考虑堆数不为0，所以对于len，就是有1-len的堆数，实际我们会对于j范围是[0,len],其中0是留空的情况

#### 初始化
全部为0

#### 计算

- 答案是在一开始得到，那么需要倒序，即从后往前去计算
- 循环顺序则是 i在前面，后面是j
- 对于当前选择d[i][j]，需要考虑两种情况，定义len为全部堆数
  - i+2*j >= len 即这一次可以把全部石子都取完，那就是最优解法
  - i+2*j < len 这里需要考虑遍历各种选择去找到最大情况
    - 考虑当前选择堆数 x ，范围是[1,2*j]
    - max(sum - d[i+x][max(j,x)]), 其中sum是累加的和（从后往前计算的），而后者就是下家的最大值，差值则是当前的结果
#### 结果
d[0][1]: 初始时候[0,len-1]的石子，而第二个1表示一开始M=1

